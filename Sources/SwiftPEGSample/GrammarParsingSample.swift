import Foundation
import ArgumentParser
import SwiftPEG

private let _hardcodedPath = #file

class GrammarParsingSample: ParsableCommand {
    @Flag(
        name: [.long, .customShort("v")],
        help: "Whether to emit diagnostics during parsing."
    )
    var verbose: Bool = false

    @Flag(
        name: [.long, .customShort("b")],
        help: "Whether to use built-in grammar files."
    )
    var useBuiltInFiles: Bool = false

    @Flag(
        name: [.long, .customShort("t")],
        help: "Whether to emit a token type generated by SwiftCodeGen."
    )
    var emitTokenType: Bool = false

    @Flag(
        name: [.long, .customShort("l")],
        help: "Whether to emit a syntax node layout generated by SyntaxNodeLayoutGen."
    )
    var emitSyntaxNodeLayout: Bool = false

    @Flag(
        name: [.long, .customShort("o")],
        help: """
        Whether to emit parser code that omits redundant mark/restore calls.
        In some circumstances, actions might desire to use the local _mark for referencing
        the current point in the tokenizer, which could break if this flag is true.
        """
    )
    var omitRedundantMarkRestores: Bool = false

    @Option(
        name: [.long, .customShort("g")],
        help: """
        A SwiftPEG grammar file (usually .gram) to use. If not provided, defaults
        to built-in known grammar file paths.
        """
    )
    var grammarFilePath: String?

    var grammarFileURL: URL? {
        grammarFilePath.map(URL.init(fileURLWithPath:))
    }

    required init() {

    }

    func run() throws {
        try parse()
    }

    func activeGrammarURL() -> URL {
        if let grammarFileURL {
            return grammarFileURL
        }

        if useBuiltInFiles {
            guard let url = SwiftPEG.Resources.resources.url(forResource: "metagrammar.gram", withExtension: nil) else {
                fatalError("Could not find file metagrammar.gram!")
            }

            return url
        } else {
            let current = URL(fileURLWithPath: _hardcodedPath)

            return current
                .deletingLastPathComponent()
                .deletingLastPathComponent()
                .appendingPathComponent("SwiftPEG")
                .appendingPathComponent("Grammar")
                .appendingPathComponent("metagrammar.gram")
        }
    }

    func resolveRelativeFileName(_ name: String) -> URL {
        let baseURL = activeGrammarURL()

        return baseURL.deletingLastPathComponent().appendingPathComponent(name)
    }

    func parse() throws {
        let file = activeGrammarURL()

        if verbose {
            print("Parsing \(file)...")
        }

        let fileString = try String(contentsOf: file, encoding: .utf8)

        let tokenizer = GrammarRawTokenizer(source: fileString)
        let parser = GrammarParser(raw: tokenizer)

        let stopwatch = Stopwatch.start()

        if verbose {
            print("Parsing metagrammar.gram...")
        }

        guard let grammar = try parser.grammar() else {
            throw parser.makeSyntaxError()
        }

        let duration = stopwatch.stop()
        if verbose {
            print("Success! Parsed in \(String(format: "%.2lf", duration))s")
        }

        if try !parser.isEOF() {
            let visitor = PrintingNodeVisitor()
            let walker = NodeWalker(visitor: visitor)
            try walker.walk(grammar)

            print("Warning: Tokenizer did not consume entire file!", to: &standardError)

            print(parser.makeSyntaxError().description, to: &standardError)

            print("Remaining tokens:", to: &standardError)

            var tokens: [Substring] = []
            while let next = try tokenizer.next() {
                tokens.append(next.rawToken.string)
            }

            print(tokens, to: &standardError)
        } else {
            if verbose {
                print("Number of meta-properties: \(grammar.metas.count)")

                for property in grammar.metas {
                    if let value = property.value {
                        print("@\(property.name.string) = \(value.shortDebugDescription)")
                    } else {
                        print("@\(property.name.string)")
                    }
                }

                print("Number of rules: \(grammar.rules.count)")

                for rule in grammar.rules {
                    if let type = rule.name.type {
                        print("\(rule.ruleName) (of type \(type.description))")
                    } else {
                        print("\(rule.ruleName)")
                    }
                }
            }

            let processor = GrammarProcessor(delegate: self, verbose: verbose)
            let result = try processor.process(grammar)

            for diagnostic in processor.diagnostics {
                print(diagnostic.description, to: &standardError)
            }

            let swiftCodeGen = SwiftCodeGen(from: result)

            let code: String
            let codeKind: String

            if emitTokenType {
                code = try swiftCodeGen.generateTokenType(
                    settings: .init(
                        emitInlinable: true,
                        accessLevel: "public",
                        emitLengthSwitchPhaseInTokenOcclusionSwitch: false
                    )
                )

                codeKind = "token type code"
            } else if emitSyntaxNodeLayout {
                let gen = SyntaxNodeLayoutGen(processedGrammar: result)
                let syntaxNodes = try gen.generateSyntaxNodes()

                let buffer = NodeLayoutDebugBuffer()

                for node in syntaxNodes {
                    buffer.add(node)
                }

                code = buffer.finish()

                codeKind = "syntax node layout"
            } else {
                code = try swiftCodeGen.generateParser(
                    settings: .default.with(
                        \.omitRedundantMarkRestores,
                        value: omitRedundantMarkRestores
                    )
                )
                codeKind = "parser code"
            }

            if verbose {
                print("Generated \(codeKind):")
                print("-------------------------------------------------")
            }
            print(code)
        }
    }
}

extension GrammarParsingSample: GrammarProcessor.Delegate {

    func grammarProcessor(
        _ processor: GrammarProcessor,
        loadTokensFileNamed name: String,
        ofGrammar grammar: SwiftPEGGrammar.Grammar
    ) throws -> String {

        let url = resolveRelativeFileName(name)

        return try String(contentsOf: url)
    }

    enum Error: Swift.Error {
        case tokensFileNotFound(String)
    }
}

class NodeLayoutDebugBuffer {
    private var buffer: String = ""

    private var indentation: String = "  "

    private var indentDepth: Int = 0

    private var indentString: String {
        let value = String(repeating: indentation, count: indentDepth)
        return value
    }

    init() {
    }

    func finish() -> String {
        buffer.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    func add(_ node: SyntaxNode) {
        inline(node.name)
        block {
            add(node.layout)
        }
        line()
    }

    func add(_ layout: SyntaxNodeLayout) {
        switch layout {
        case .fixed(let fields):
            for field in fields {
                inline(field.label)

                switch field.layout {
                case .rule(field.label), .token(field.label):
                    line()

                default:
                    inline(": ")
                    add(field.layout)
                }
            }

        case .oneOf(let layouts):
            line("one of:")
            for (i, layout) in layouts.enumerated() {
                if i > 0 {
                    line("or:")
                }
                indented {
                    add(layout)
                }
            }

        case .collectionOf(let layout):
            switch layout {
            case .rule, .token:
                inline("[")
                add(layout)
                backtrackSpace()
                line("]")
            default:
                line("collectionOf:")
                indented {
                    add(layout)
                }
            }

        case .optional(let layout):
            switch layout {
            case .rule, .token, .optional(.rule), .optional(.token):
                add(layout)
                backtrackSpace()
                line("?")

            default:
                line("optional:")
                indented {
                    add(layout)
                }
            }

        case .labeled(let label, let layout):
            line("labeled:")
            indented {
                line(label)
                add(layout)
            }

        case .rule(let name):
            line(name)

        case .token(let name):
            line(name)
        }
    }

    //

    func block(_ production: () -> Void) {
        ensureSpace()
        line("{")

        indented(production)

        ensureNewline()
        line("}")
    }

    func indented(_ production: () -> Void) {
        indent()
        production()
        unindent()
    }

    func indent() {
        indentDepth += 1
    }

    func unindent() {
        indentDepth -= 1
    }

    func ensureSpace() {
        if buffer.last?.isWhitespace == false {
            buffer += " "
        }
    }

    func ensureNewline() {
        if buffer.last?.isNewline == false {
            buffer += "\n"
        }
    }

    func isOnNewline() -> Bool {
        buffer.last?.isNewline == true
    }

    func isOnSpace() -> Bool {
        buffer.last?.isWhitespace == true
    }

    func inline(_ text: String) {
        if isOnNewline() {
            buffer += indentString
        }
        buffer += text
    }

    func backtrackSpace() {
        while isOnSpace() {
            buffer.removeLast()
        }
    }

    func line(_ text: String = "") {
        if isOnNewline() {
            buffer += indentString
        }
        buffer += text
        buffer += "\n"
    }
}
