# Grammar for SwiftPEG - based on https://github.com/we-like-parsers/pegen_experiments/blob/master/pegen/metagrammar.gram (see LICENSE.pegen.md)
# This metagrammar requires the GrammarRawTokenizer for tokenizing.

@parserName "GrammarParser" ;
@parserHeader """
// HEADS UP! This is a generated file

/// A parser for SwiftPEG grammar files.
public final class GrammarParser<RawTokenizer: RawTokenizerType>: PEGParser<RawTokenizer>
    where RawTokenizer.Token == SwiftPEGGrammar.GrammarToken, RawTokenizer.Location == FileSourceLocation
{ }
""" ;

@tokensFile "metagrammar.tokens" ;
@tokenCall expectKind ;
@anyToken ANY ;


# Start of grammar

start[SwiftPEGGrammar.Grammar]: grammar { grammar } ;

grammar[SwiftPEGGrammar.Grammar]:
    | metas=meta* rules=rule+ { self.setLocation(.init(metas: metas, rules: rules), at: mark) }
    ;

meta[SwiftPEGGrammar.Meta]:
    | "@" name=IDENTIFIER value=metaValue? ';' { self.setLocation(.init(name: name.token, value: value), at: mark) }
    ;

metaValue[SwiftPEGGrammar.MetaValue]:
    | ident=IDENTIFIER  { self.setLocation(SwiftPEGGrammar.MetaIdentifierValue(identifier: ident.token), at: mark) }
    | string=STRING     { self.setLocation(SwiftPEGGrammar.MetaStringValue(string: string.token), at: mark) }
    ;

rule[SwiftPEGGrammar.Rule]:
    | ruleName ":" '|'? alts ';'    { self.setLocation(.init(name: ruleName, alts: alts), at: mark) }
    ;

ruleName[SwiftPEGGrammar.RuleName]:
    | name=IDENTIFIER '[' ~ type=swiftType ']'  { self.setLocation(.init(name: name.token, type: type), at: mark) }
    | name=IDENTIFIER                           { self.setLocation(.init(name: name.token, type: nil), at: mark) }
    ;

alts[[SwiftPEGGrammar.Alt]]:
    | "|".alt+
    ;

alt[SwiftPEGGrammar.Alt]:
    | namedItems action? failAction?    { self.setLocation(.init(namedItems: namedItems, action: action, failAction: failAction), at: mark) }
    ;

namedItems[[SwiftPEGGrammar.NamedItem]]:
    | namedItem+
    ;

namedItem[SwiftPEGGrammar.NamedItem]:
    | name=IDENTIFIER '[' type=swiftType ']' '=' ~ item     { self.setLocation(.init(name: name.token, item: item, type: type, lookahead: nil), at: mark) }
    | name=IDENTIFIER '=' ~ item                            { self.setLocation(.init(name: name.token, item: item, type: nil, lookahead: nil), at: mark) }
    | item                                                  { self.setLocation(.init(name: nil, item: item, type: nil, lookahead: nil), at: mark) }
    | lookahead                                             { self.setLocation(.init(name: nil, item: nil, type: nil, lookahead: lookahead), at: mark) }
    ;

lookahead[SwiftPEGGrammar.LookaheadOrCut]:
    | '&' ~ atom    { self.setLocation(SwiftPEGGrammar.PositiveLookahead(atom: atom), at: mark) }
    | '!' ~ atom    { self.setLocation(SwiftPEGGrammar.NegativeLookahead(atom: atom), at: mark) }
    | '~'           { self.setLocation(SwiftPEGGrammar.Cut(), at: mark) }
    ;

item[SwiftPEGGrammar.Item]:
    | '[' ~ alts ']'                { self.setLocation(SwiftPEGGrammar.OptionalItems(alts: alts), at: mark) }
    |  atom '?'                     { self.setLocation(SwiftPEGGrammar.OptionalItem(atom: atom), at: mark) }
    |  atom '*'                     { self.setLocation(SwiftPEGGrammar.ZeroOrMoreItem(atom: atom), at: mark) }
    |  atom '+'                     { self.setLocation(SwiftPEGGrammar.OneOrMoreItem(atom: atom), at: mark) }
    |  sep=atom '.' node=atom '+'   { self.setLocation(SwiftPEGGrammar.GatherItem(sep: sep, item: node), at: mark) }
    |  atom                         { self.setLocation(SwiftPEGGrammar.AtomItem(atom: atom), at: mark) }
    ;

atom[SwiftPEGGrammar.Atom]:
    | '(' ~ alts ')'    { self.setLocation(SwiftPEGGrammar.GroupAtom(alts: alts), at: mark) }
    | IDENTIFIER        { self.setLocation(SwiftPEGGrammar.IdentAtom(identifier: identifier.token, identity: .unresolved), at: mark) }
    | STRING            { self.setLocation(SwiftPEGGrammar.StringAtom(string: string.token), at: mark) }
    ;

swiftType[CommonAbstract.SwiftType]:
    | '[' key=swiftType ':' ~ value=swiftType ']'       { .dictionary(key: key, value: value) }
    | '[' ~ swiftType ']'                               { .array(swiftType) }
    | swiftType '?'                                     { .optional(swiftType) }
    | swiftType '.' IDENTIFIER '<' swiftTypeList '>'    { .nested(swiftType, .init(identifier: identifier.token.string, genericArguments: swiftTypeList)) }
    | swiftType '.' IDENTIFIER                          { .nested(swiftType, .init(identifier: identifier.token.string)) }
    | IDENTIFIER '<' swiftTypeList '>'                  { .nominal(.init(identifier: identifier.token.string, genericArguments: swiftTypeList)) }
    | IDENTIFIER                                        { .nominal(.init(identifier: identifier.token.string)) }
    ;

swiftTypeList[[CommonAbstract.SwiftType]]:
    | ','.swiftType+
    ;


# Mini-grammar for the actions

action[SwiftPEGGrammar.Action]:
    | "{" ~ balancedTokens "}"                  { self.setLocation(.init(balancedTokens: balancedTokens), at: mark) }
    ;

failAction[SwiftPEGGrammar.Action]:
    | "!!" "{" ~ balancedTokens "}"             { self.setLocation(.init(balancedTokens: balancedTokens), at: mark) }
    ;

balancedTokens[SwiftPEGGrammar.BalancedTokens]:
    | balancedToken balancedTokens              { self.setLocation(.init(tokens: balancedToken.tokens + balancedTokens.tokens), at: mark) }
    | balancedToken                             { balancedToken }
    ;

balancedToken[SwiftPEGGrammar.BalancedTokens]:
      # Explicitly consume whitespace prior to other token kinds since whitespace gets skipped automatically, if it's not explicitly being checked for
    | token=WHITESPACE                          { self.setLocation(.init(tokens: [.init(token)]), at: mark) }
    | l='{' balancedTokens r='}'                { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='[' balancedTokens r=']'                { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='<' balancedTokens r='>'                { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='(' balancedTokens r=')'                { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='[' ~ r=']'                             { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='{' ~ r='}'                             { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='<' ~ r='>'                             { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='(' ~ r=')'                             { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | token=balancedTokenAtom                   { .init(tokens: [token]) }
    ;

balancedTokenAtom[TokenNode<RawTokenizer.Token, RawTokenizer.Location>]:
    | !"[" !"]" !"{" !"}" !"(" !")" token=ANY   { .init(token) }
    ;


# Tokens file grammar

tokensFile[[SwiftPEGGrammar.TokenDefinition]]:
    | tokens=tokenDefinition* { tokens }
    ;

# Note: staticToken must resolve statically to a token reference when PEGParser.expect()/PEGParser.expect(kind:) uses it as its argument.
#       Usually this can be simplified to a `.tokenReference` for TokenType/TokenType.TokenKind types that provide statically-accessible token declarations,
#       but may be any Swift expression that resolves to the desired token when paired with an appropriate tokenizer's token type.
tokenDefinition[SwiftPEGGrammar.TokenDefinition]:
    | '$' name=IDENTIFIER '[' staticToken=STRING ']' ':' ~ literal=STRING ';' { self.setLocation(.init(name: name.token, staticToken: staticToken.token, literal: literal.token), at: mark) }
    | '$' name=IDENTIFIER '[' staticToken=STRING ']' ';'                      { self.setLocation(.init(name: name.token, staticToken: staticToken.token, literal: nil), at: mark) }
    | '$' name=IDENTIFIER ':' ~ literal=STRING ';'                            { self.setLocation(.init(name: name.token, staticToken: nil, literal: literal.token), at: mark) }
    | '$' name=IDENTIFIER ';'                                                 { self.setLocation(.init(name: name.token, staticToken: nil, literal: nil), at: mark) }
    ;
