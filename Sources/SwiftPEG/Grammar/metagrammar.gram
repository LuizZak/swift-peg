# Grammar for SwiftPEG - based on https://github.com/we-like-parsers/pegen_experiments/blob/master/pegen/metagrammar.gram (see LICENSE.pegen.md)
# This metagrammar requires the GrammarRawTokenizer for tokenizing.

@parserName "GrammarParser" ;
@parserHeader """
// HEADS UP! This is a generated file

/// A parser for SwiftPEG grammar files.
public final class GrammarParser<RawTokenizer: RawTokenizerType>: PEGParser<RawTokenizer>
    where RawTokenizer.Token == SwiftPEGGrammar.Token, RawTokenizer.Location == FileSourceLocation
{ }
""" ;

@tokensFile "metagrammar.tokens" ;
@tokenCall expectKind ;
@anyToken ANY ;


# Start of grammar

start[SwiftPEGGrammar.Grammar]: grammar { grammar } ;

grammar[SwiftPEGGrammar.Grammar]:
    | metas=meta* rules=rule+ { self.setLocation(.init(metas: metas, rules: rules), at: mark) }
    ;

meta[SwiftPEGGrammar.Meta]:
    | "@" name=IDENTIFIER value=metaValue? ';' { self.setLocation(.init(name: name.token, value: value), at: mark) }
    ;

metaValue[SwiftPEGGrammar.MetaValue]:
    | ident=IDENTIFIER  { self.setLocation(SwiftPEGGrammar.MetaIdentifierValue(identifier: ident.token), at: mark) }
    | string            { self.setLocation(SwiftPEGGrammar.MetaStringValue(string: string), at: mark) }
    ;

rule[SwiftPEGGrammar.Rule]:
    | ruleName ":" '|'? alts ';'    { self.setLocation(.init(name: ruleName, alts: alts), at: mark) }
    ;

ruleName[SwiftPEGGrammar.RuleName]:
    | name=IDENTIFIER '[' ~ type=swiftType ']'  { self.setLocation(.init(name: name.token, type: type), at: mark) }
    | name=IDENTIFIER                           { self.setLocation(.init(name: name.token, type: nil), at: mark) }
    ;

alts[[SwiftPEGGrammar.Alt]]:
    | "|".alt+
    ;

alt[SwiftPEGGrammar.Alt]:
    | namedItems action? failAction?    { self.setLocation(.init(namedItems: namedItems, action: action, failAction: failAction), at: mark) }
    ;

namedItems[[SwiftPEGGrammar.NamedItem]]:
    | namedItem+
    ;

namedItem[SwiftPEGGrammar.NamedItem]:
    | name=IDENTIFIER '[' type=swiftType ']' '=' ~ item     { self.setLocation(.init(name: name.token, item: item, type: type, lookahead: nil), at: mark) }
    | name=IDENTIFIER '=' ~ item                            { self.setLocation(.init(name: name.token, item: item, type: nil, lookahead: nil), at: mark) }
    | item                                                  { self.setLocation(.init(name: nil, item: item, type: nil, lookahead: nil), at: mark) }
    | lookahead                                             { self.setLocation(.init(name: nil, item: nil, type: nil, lookahead: lookahead), at: mark) }
    ;

lookahead[SwiftPEGGrammar.LookaheadOrCut]:
    | '&''&' ~ atom   { self.setLocation(SwiftPEGGrammar.Forced(atom: atom), at: mark) }
    | '&' ~ atom    { self.setLocation(SwiftPEGGrammar.PositiveLookahead(atom: atom), at: mark) }
    | '!' ~ atom    { self.setLocation(SwiftPEGGrammar.NegativeLookahead(atom: atom), at: mark) }
    | '~'           { self.setLocation(SwiftPEGGrammar.Cut(), at: mark) }
    ;

item[SwiftPEGGrammar.Item]:
    | '[' ~ alts ']'                                { self.setLocation(SwiftPEGGrammar.OptionalItems(alts: alts), at: mark) }
    |  atom '?'                                     { self.setLocation(SwiftPEGGrammar.OptionalItem(atom: atom), at: mark) }
    |  atom '*' repetitionMode?                     { self.setLocation(SwiftPEGGrammar.ZeroOrMoreItem(atom: atom, repetitionMode: repetitionMode ?? .standard), at: mark) }
    |  atom '+' repetitionMode?                     { self.setLocation(SwiftPEGGrammar.OneOrMoreItem(atom: atom, repetitionMode: repetitionMode ?? .standard), at: mark) }
    |  sep=atom '.' node=atom '+' repetitionMode?   { self.setLocation(SwiftPEGGrammar.GatherItem(sep: sep, item: node, repetitionMode: repetitionMode ?? .standard), at: mark) }
    |  atom                                         { self.setLocation(SwiftPEGGrammar.AtomItem(atom: atom), at: mark) }
    ;
repetitionMode[CommonAbstract.RepetitionMode]:
    | '<'                                           { .minimal }
    | '>'                                           { .maximal }
    ;

atom[SwiftPEGGrammar.Atom]:
    | '(' ~ alts ')'    { self.setLocation(SwiftPEGGrammar.GroupAtom(alts: alts), at: mark) }
    | IDENTIFIER        { self.setLocation(SwiftPEGGrammar.IdentAtom(identifier: identifier.token, identity: .unresolved), at: mark) }
    | string            { self.setLocation(SwiftPEGGrammar.StringAtom(string: string), at: mark) }
    ;

swiftType[CommonAbstract.SwiftType]:
    | '(' swiftTupleTypeList? ')'                       { .tuple(swiftTupleTypeList ?? []) }
    | '[' key=swiftType ':' ~ value=swiftType ']'       { .dictionary(key: key, value: value) }
    | '[' ~ swiftType ']'                               { .array(swiftType) }
    | swiftType '?'                                     { .optional(swiftType) }
    | swiftType '.' IDENTIFIER '<' swiftTypeList '>'    { .nested(swiftType, .init(identifier: "\(identifier)", genericArguments: swiftTypeList)) }
    | swiftType '.' IDENTIFIER                          { .nested(swiftType, .init(identifier: "\(identifier)")) }
    | IDENTIFIER '<' swiftTypeList '>'                  { .nominal(.init(identifier: "\(identifier)", genericArguments: swiftTypeList)) }
    | IDENTIFIER                                        { .nominal(.init(identifier: "\(identifier)")) }
    ;

swiftTypeList[[CommonAbstract.SwiftType]]:
    | ','.swiftType+
    ;

swiftTupleTypeList[[CommonAbstract.TupleTypeElement]]:
    | ','.swiftTupleTypeElement+
    ;

swiftTupleTypeElement[CommonAbstract.TupleTypeElement]:
    | label=IDENTIFIER ':' swiftType    { .labeled(label: "\(label)", swiftType) }
    | swiftType                         { .unlabeled(swiftType) }
    ;

# Mini-grammar for the actions

action[SwiftPEGGrammar.Action]:
    | "{" ~ balancedTokens "}"                  { self.setLocation(.init(balancedTokens: balancedTokens), at: mark) }
    ;

failAction[SwiftPEGGrammar.Action]:
    | "!!" "{" ~ balancedTokens "}"             { self.setLocation(.init(balancedTokens: balancedTokens), at: mark) }
    ;

balancedTokens[SwiftPEGGrammar.TokenSequence]:
    | balancedToken+                            { .from(balancedToken) }
    ;

balancedToken[SwiftPEGGrammar.TokenSequence]:
      # Explicitly consume whitespace prior to other token kinds since whitespace gets skipped automatically, if it's not explicitly being checked for
    | token=WHITESPACE                          { .from(token) }
    | l='{' ~ balancedToken* r='}'              { .from(l).appending(contentsOf: balancedToken).appending(.from(r)) }
    | l='[' ~ balancedToken* r=']'              { .from(l).appending(contentsOf: balancedToken).appending(.from(r)) }
    | l='<' ~ balancedToken* r='>'              { .from(l).appending(contentsOf: balancedToken).appending(.from(r)) }
    | l='(' ~ balancedToken* r=')'              { .from(l).appending(contentsOf: balancedToken).appending(.from(r)) }
    | token=balancedTokenAtom                   { token }
    ;

balancedTokenAtom[SwiftPEGGrammar.TokenSequence]:
    | string                                    { .from(string) }
    | !"[" !"]" !"{" !"}" !"(" !")" token=ANY   { .from(token) }
    ;


# Strings

string[SwiftPEGGrammar.GrammarString]:
    | token=STRING                     { try .fromStringToken(token) }
    ;


# Tokens file grammar

tokensFile[[SwiftPEGGrammar.TokenDefinition]]:
    | tokens=tokenDefinition*
    ;

# TODO: Consider implementing lexer channels if needs be?
# tokensFile[[SwiftPEGGrammar.TokenFileDeclaration]]:
#     | tokensFileDeclaration*
#     ;
# 
# tokensFileDeclaration[[SwiftPEGGrammar.TokenFileDeclaration]]:
#     | tokenDefinition
#     | tokenChannelDeclaration
#     ;
# 
# tokenChannelDeclaration[[SwiftPEGGrammar.TokenChannel]]:
#     | '@' IDENTIFIER                            { "\(identifier)" == "channel" ? self.setLocation(.init(identifier: identifier), at: mark) : nil }
#     ;

# Note: staticToken must resolve statically to a token reference when PEGParser.expect()/PEGParser.expect(kind:) uses it as its argument.
#       Usually this can be simplified to a `.tokenReference` for TokenType/TokenType.TokenKind types that provide statically-accessible token declarations,
#       but may be any Swift expression that resolves to the desired token when paired with an appropriate tokenizer's token type.
tokenDefinition[SwiftPEGGrammar.TokenDefinition]:
    | spec=tokenOrFragmentSpecifier name=IDENTIFIER '[' staticToken=string ']' ':' ~ tokenSyntax ';'    { self.setLocation(.init(name: name.token, isFragment: spec.kind == .percent, staticToken: staticToken, tokenSyntax: tokenSyntax), at: mark) }
    | spec=tokenOrFragmentSpecifier name=IDENTIFIER '[' staticToken=string ']' ';'                      { self.setLocation(.init(name: name.token, isFragment: spec.kind == .percent, staticToken: staticToken, tokenSyntax: nil), at: mark) }
    | spec=tokenOrFragmentSpecifier name=IDENTIFIER ':' ~ tokenSyntax ';'                               { self.setLocation(.init(name: name.token, isFragment: spec.kind == .percent, staticToken: nil, tokenSyntax: tokenSyntax), at: mark) }
    | spec=tokenOrFragmentSpecifier name=IDENTIFIER ';'                                                 { self.setLocation(.init(name: name.token, isFragment: spec.kind == .percent, staticToken: nil, tokenSyntax: nil), at: mark) }
    ;

tokenOrFragmentSpecifier[Token]:
    | token='$'   { token.token }
    | token='%'   { token.token }
    ;

tokenSyntax[CommonAbstract.TokenSyntax]:
    | '|'? '|'.tokenSyntaxAlt+                      { .init(alts: tokenSyntaxAlt) }
    ;

tokenSyntaxAlt[CommonAbstract.TokenAlt]:
    | tokenSyntaxItem+                              { .init(items: tokenSyntaxItem) }
    ;

tokenSyntaxItem[CommonAbstract.TokenItem]:
    | '(' '|'.tokenSyntaxAtom+ ')' '*'              { .zeroOrMore(tokenSyntaxAtom) }
    | '(' '|'.tokenSyntaxAtom+ ')' '+'              { .oneOrMore(tokenSyntaxAtom) }
    | '(' '|'.tokenSyntaxAtom+ ')' '?'              { .optionalGroup(tokenSyntaxAtom) }
    | '(' '|'.tokenSyntaxAtom+ ')'                  { .group(tokenSyntaxAtom) }
    | tokenSyntaxAtom '*'                           { .zeroOrMore([tokenSyntaxAtom]) }
    | tokenSyntaxAtom '+'                           { .oneOrMore([tokenSyntaxAtom]) }
    # TODO: Maybe collapse optionalAtom into optionalGroup?
    | tokenSyntaxAtom '?'                           { .optionalAtom(tokenSyntaxAtom) }
    | tokenSyntaxAtom                               { .atom(tokenSyntaxAtom) }
    ;

tokenSyntaxAtom[CommonAbstract.TokenAtom]:
    | tokenSyntaxExclusion* tokenSyntaxTerminal     { .init(excluded: tokenSyntaxExclusion, terminal: tokenSyntaxTerminal) }
    ;

tokenSyntaxExclusion[CommonAbstract.TokenExclusion]:
    | '!' string                                    { .string(.from(string)) }
    | '!' IDENTIFIER                                { .identifier("\(identifier)") }
    ;

tokenSyntaxTerminal[CommonAbstract.TokenTerminal]:
    | IDENTIFIER action                             { .characterPredicate("\(identifier)", action.rawAction) }
    | start=string '...' end=string                 { .rangeLiteral(.from(start), .from(end)) }
    | string                                        { .literal(.from(string)) }
    | IDENTIFIER                                    { .identifier("\(identifier)") }
    | '.'                                           { .any }
    ;
