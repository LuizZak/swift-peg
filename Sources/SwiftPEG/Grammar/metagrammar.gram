# Metagrammar for SwiftPEG - based on https://github.com/we-like-parsers/pegen_experiments/blob/master/pegen/metagrammar.gram (see LICENSE.pegen.md)
# This metagrammar requires the MetagrammarRawTokenizer for tokenizing.

@parserName "MetagrammarParser" ;
@parserHeader """
// HEADS UP! This is a generated file

/// A parser for SwiftPEG grammar files.
public final class MetagrammarParser<RawTokenizer: RawTokenizerType>: PEGParser<RawTokenizer>
    where RawTokenizer.Token == Metagrammar.MetagrammarToken, RawTokenizer.Location == FileSourceLocation
{ }
""" ;

@tokensFile "metagrammar.tokens" ;
@tokenCall expectKind ;

# Start of grammar

start[Metagrammar.Grammar]: grammar { grammar } ;

grammar[Metagrammar.Grammar]:
    | metas rules { self.setLocation(.init(metas: metas, rules: rules), at: mark) }
    | rules { self.setLocation(.init(metas: [], rules: rules), at: mark) }
    ;

metas[[Metagrammar.Meta]]:
    | metas=meta+ { metas }
    ;

meta[Metagrammar.Meta]:
    | "@" name=IDENTIFIER value=metaValue ';' { self.setLocation(.init(name: name.token, value: value), at: mark) }
    | "@" name=IDENTIFIER ';' { self.setLocation(.init(name: name.token, value: nil), at: mark) }
    ;

metaValue[Metagrammar.MetaValue]:
    | ident=IDENTIFIER { self.setLocation(Metagrammar.MetaIdentifierValue(identifier: ident.token), at: mark) }
    | string=STRING { self.setLocation(Metagrammar.MetaStringValue(string: string.token), at: mark) }
    ;

rules[[Metagrammar.Rule]]:
    | rules=rule+ { rules }
    ;

rule[Metagrammar.Rule]:
    | ruleName ":" '|' alts ';' { self.setLocation(.init(name: ruleName, alts: alts), at: mark) }
    | ruleName ":" alts ';' { self.setLocation(.init(name: ruleName, alts: alts), at: mark) }
    ;

ruleName[Metagrammar.RuleName]:
    | name=IDENTIFIER '[' type=swiftType ']' { self.setLocation(.init(name: name.token, type: type), at: mark) }
    | name=IDENTIFIER { self.setLocation(.init(name: name.token, type: nil), at: mark) }
    ;

alts[[Metagrammar.Alt]]:
    | alt "|" alts { [alt] + alts }
    | alt { [alt] }
    ;

alt[Metagrammar.Alt]:
    | namedItems action { self.setLocation(.init(namedItems: namedItems, action: action), at: mark) }
    | namedItems { self.setLocation(.init(namedItems: namedItems, action: nil), at: mark) }
    ;

namedItems[[Metagrammar.NamedItem]]:
    | namedItem namedItems { [namedItem] + namedItems }
    | namedItem { [namedItem] }
    ;

namedItem[Metagrammar.NamedItem]:
    | name=IDENTIFIER '[' type=swiftType ']' '=' ~ item { self.setLocation(.init(name: name.token, item: item, type: type, lookahead: nil), at: mark) }
    | name=IDENTIFIER '=' ~ item { self.setLocation(.init(name: name.token, item: item, type: nil, lookahead: nil), at: mark) }
    | item { self.setLocation(.init(name: nil, item: item, type: nil, lookahead: nil), at: mark) }
    | lookahead { self.setLocation(.init(name: nil, item: nil, type: nil, lookahead: lookahead), at: mark) }
    ;

lookahead[Metagrammar.LookaheadOrCut]:
    | '&' ~ atom { self.setLocation(Metagrammar.PositiveLookahead(atom: atom), at: mark) }
    | '!' ~ atom { self.setLocation(Metagrammar.NegativeLookahead(atom: atom), at: mark) }
    | '~' { self.setLocation(Metagrammar.Cut(), at: mark) }
    ;

item[Metagrammar.Item]:
    | '[' ~ alts ']' { self.setLocation(Metagrammar.OptionalItems(alts: alts), at: mark) }
    |  atom '?' { self.setLocation(Metagrammar.OptionalItem(atom: atom), at: mark) }
    |  atom '*' { self.setLocation(Metagrammar.ZeroOrMoreItem(atom: atom), at: mark) }
    |  atom '+' { self.setLocation(Metagrammar.OneOrMoreItem(atom: atom), at: mark) }
    |  sep=atom '.' node=atom '+' { self.setLocation(Metagrammar.GatherItem(sep: sep, item: node), at: mark) }
    |  atom { self.setLocation(Metagrammar.AtomItem(atom: atom), at: mark) }
    ;

atom[Metagrammar.Atom]:
    | '(' ~ alts ')' { self.setLocation(Metagrammar.GroupAtom(alts: alts), at: mark) }
    | IDENTIFIER { self.setLocation(Metagrammar.IdentAtom(identifier: identifier.token, identity: .unresolved), at: mark) }
    | STRING { self.setLocation(Metagrammar.StringAtom(string: string.token), at: mark) }
    ;

swiftType[Metagrammar.SwiftType]:
    | raw=STRING { self.setLocation(.init(name: raw.token.processedString), at: mark) }
    | '[' ~ type=swiftType ']' { self.setLocation(.init(name: "[" + type.name + "]"), at: mark) }
    | '(' ~ types=swiftTypeList ')' { self.setLocation(.init(name: "(" + types.map(\.name).joined(separator: ", ") + ")"), at: mark) }
    | name=IDENTIFIER '<' ~ types=swiftTypeList '>' '?' { self.setLocation(.init(name: name.token.string + "<" + types.map(\.name).joined(separator: ", ") + ">?"), at: mark) }
    | name=IDENTIFIER '<' ~ types=swiftTypeList '>' { self.setLocation(.init(name: name.token.string + "<" + types.map(\.name).joined(separator: ", ") + ">"), at: mark) }
    | name=IDENTIFIER '.' ~ inner=swiftType { self.setLocation(.init(name: name.token.string + "." + inner.name), at: mark) }
    | name=IDENTIFIER '?' { self.setLocation(.init(name: name.token.string + "?"), at: mark) }
    | name=IDENTIFIER { self.setLocation(.init(name: name.token.string), at: mark) }
    ;

swiftTypeList[[Metagrammar.SwiftType]]:
    | type=swiftType ',' types=swiftTypeList { [type] + types }
    | type=swiftType { [type] }
    ;

# Mini-grammar for the actions

action[Metagrammar.Action]:
    | "{" ~ balancedTokens "}" { self.setLocation(.init(balancedTokens: balancedTokens), at: mark) }
    ;

balancedTokens[Metagrammar.BalancedTokens]:
    | balancedToken balancedTokens  { self.setLocation(.init(tokens: balancedToken.tokens + balancedTokens.tokens), at: mark) }
    | balancedToken  { balancedToken }
    ;

balancedToken[Metagrammar.BalancedTokens]:
    | token=WHITESPACE { self.setLocation(.init(tokens: [.init(token)]), at: mark) }
    | l='{' balancedTokens r='}' { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='[' balancedTokens r=']' { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='<' balancedTokens r='>' { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='(' balancedTokens r=')' { self.setLocation(.init(tokens: [.init(l)] + balancedTokens.tokens + [.init(r)]), at: mark) }
    | l='[' ~ r=']' { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='{' ~ r='}' { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='<' ~ r='>' { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | l='(' ~ r=')' { self.setLocation(.init(tokens: [.init(l), .init(r)]), at: mark) }
    | token=balancedTokenAtom { .init(tokens: [token]) }
    ;

balancedTokenAtom["TokenNode<RawTokenizer.Token, RawTokenizer.Location>"]:
    | token=IDENTIFIER { .init(token) }
    | token=DIGITS { .init(token) }
    | token=STRING { .init(token) }
    | token=':' { .init(token) }
    | token=';' { .init(token) }
    | token='|' { .init(token) }
    | token='=' { .init(token) }
    | token='~' { .init(token) }
    | token='*' { .init(token) }
    | token='+' { .init(token) }
    | token='?' { .init(token) }
    | token=',' { .init(token) }
    | token='.' { .init(token) }
    | token='@' { .init(token) }
    | token='$' { .init(token) }
    | token='/' { .init(token) }
    | token='\' { .init(token) }
    ;

# Tokens file grammar

tokensFile[[Metagrammar.TokenDefinition]]:
    | tokens=tokenDefinition* { tokens }
    ;

tokenDefinition[Metagrammar.TokenDefinition]:
    | '$' name=IDENTIFIER '[' expectArgs=STRING ']' ':' literal=STRING ';' { self.setLocation(.init(name: name.token, expectArgs: expectArgs.token, literal: literal.token), at: mark) }
    | '$' name=IDENTIFIER ':' literal=STRING ';' { self.setLocation(.init(name: name.token, expectArgs: nil, literal: literal.token), at: mark) }
    ;
