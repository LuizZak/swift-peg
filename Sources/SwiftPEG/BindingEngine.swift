/// Manages detection of bindings of processed grammars.
class BindingEngine {
    /// Specifies the type of bindings generated by this binding engine.
    typealias Binding = (label: String?, type: CommonAbstract.SwiftType)

    var ruleAliases: [String: String] = [:]
    var knownRules: [String: InternalGrammar.Rule] = [:]
    var knownTokens: [String: InternalGrammar.TokenDefinition] = [:]

    /// Whether to implicitly generate bindings for atoms that compute into
    /// known identifiers.
    var implicitBindings: Bool = true

    /// Initializes a binding engine with the contents of the provided processed
    /// grammar object.
    init(processedGrammar: ProcessedGrammar) {
        for rule in processedGrammar.grammar.rules {
            registerRule(rule)
        }
        for token in processedGrammar.tokens {
            registerToken(token)
        }
    }

    /// Initializes an empty binding engine.
    init() {

    }

    /// Removes all known rule and token definitions from this binding engine.
    func clearState() {
        ruleAliases.removeAll()
        knownRules.removeAll()
        knownTokens.removeAll()
    }

    /// Registers a new rule into this binding engine.
    func registerRule(_ rule: InternalGrammar.Rule) {
        knownRules[rule.name] = rule
    }

    /// Registers a new token definition into this binding engine.
    func registerToken(_ token: InternalGrammar.TokenDefinition) {
        knownTokens[token.name] = token
    }

    /// Searches for a known rule with a matching name.
    ///
    /// If none are found, returns `nil`, instead.
    func findRule(named name: String) -> InternalGrammar.Rule? {
        if let rule = knownRules[name] {
            return rule
        }

        return nil
    }

    /// Returns the alias for referencing the given rule in code with
    /// `self.<rule alias>()`.
    func alias(for rule: InternalGrammar.Rule) -> String {
        if let alias = self.ruleAliases[rule.name] {
            return alias
        }

        return rule.name
    }

    /// Returns a token definition from `self.tokenDefinitions` of a matching
    /// name, or `nil`, if none is found.
    func tokenDefinition(named name: String) -> InternalGrammar.TokenDefinition? {
        knownTokens[name]
    }

    /// Returns a token definition from `self.tokenDefinitions` that has a literal
    /// value matching the given (non-quoted) value, or `nil`, if none is found.
    func tokenDefinition(ofRawLiteral literal: String) -> InternalGrammar.TokenDefinition? {
        for token in knownTokens.values {
            if token.computedLiteral == literal {
                return token
            }
        }

        return nil
    }

    /// Returns the name of a token that has a literal value matching the given
    /// (non-quoted) value, or `nil`, if none is known.
    func tokenName(ofRawLiteral literal: String) -> String? {
        tokenDefinition(ofRawLiteral: literal)?.name
    }

    // MARK: - Type derivation

    /// Returns the type to use when referring to tokens returned by a parser.
    ///
    /// - note: Only valid within `PEGParser` members.
    func swiftTokenType() -> CommonAbstract.SwiftType {
        "TokenResult"
    }

    /// Returns the default type to use when rules specify no return type.
    ///
    /// - note: Rules always have an optional layer added to their return types.
    func defaultRuleType() -> CommonAbstract.SwiftType {
        .optional("Node")
    }

    /// Returns the string to use as the return type for a given rule's method.
    ///
    /// If computing the return type with the rule's type fails, a default `Node?`
    /// type is returned, instead.
    ///
    /// If the generated type is a single-element tuple, the result is the tuple's
    /// element type.
    func returnTypeForRule(_ rule: InternalGrammar.Rule) -> String {
        let returnType = typeForRule(rule) ?? defaultRuleType()

        return returnType.scg_asValidSwiftType()
    }

    /// Attempts to statically infer the type of a given rule.
    ///
    /// - note: Rules always have an optional layer added to their return types.
    func typeForRule(_ rule: InternalGrammar.Rule) -> CommonAbstract.SwiftType? {
        return rule.type?.scg_optionalWrapped()
    }

    /// Attempts to statically infer the type of a given named item.
    ///
    /// Since named items are interpreted as if-let bindings by the code generator,
    /// the return type is optionally-unwrapped, if it is an optional type,
    /// except for items that explicitly provide a type (`name[<swiftType>]=someItem`),
    /// which returns the provided type as-is.
    func typeForNamedItem(_ namedItem: InternalGrammar.NamedItem) -> CommonAbstract.SwiftType {
        switch namedItem {
        case .item(_, _, let type?):
            return type

        case .item(_, let item, _):
            return typeForItem(item).unwrapped

        case .lookahead:
            return "Bool"
        }
    }

    /// Attempts to statically infer the type of an item.
    ///
    /// Always optionally-wrapped.
    func typeForItem(_ item: InternalGrammar.Item) -> CommonAbstract.SwiftType {
        switch item {
        case .oneOrMore(let atom, _), .zeroOrMore(let atom, _), .gather(_, let atom):
            // Remove one layer of optionality, as it's consumed by the repetition
            // process to gauge when the repetition should end
            let type = self.typeForAtom(atom).scg_unwrapped()
            return .array(type).scg_optionalWrapped()

        case .optionalItems(let alts):
            let bindings = computeBindings(alts)
            return bindings.scg_asTupleType().scg_optionalWrapped()

        case .optional(let atom):
            return typeForAtom(atom).scg_optionalWrapped()

        case .atom(let atom):
            return typeForAtom(atom)
        }
    }

    /// Attempts to statically infer the type of an atom.
    ///
    /// Can be either a token type, or a rule's production.
    /// Always optionally-wrapped.
    func typeForAtom(_ atom: InternalGrammar.Atom) -> CommonAbstract.SwiftType {
        switch atom {
        case .group(let alts):
            let bindings = computeBindings(alts)
            return bindings.scg_asTupleType().scg_optionalWrapped()

        case .anyToken, .token, .string:
            return .optional(swiftTokenType())

        case .ruleName(let ruleName):
            if let rule = findRule(named: ruleName) {
                return typeForRule(rule) ?? defaultRuleType()
            }

            return defaultRuleType()
        }
    }

    // MARK: - Binding derivation

    /// Returns bindings for a given named item, to be used for if-let binding.
    ///
    /// The result might have more than one element, in case the item expands
    /// into auxiliary rules with multiple elements.
    ///
    /// Since named items are interpreted as if-let bindings by the code generator,
    /// the return type is optionally-unwrapped, if it is an optional type,
    /// except for items that explicitly provide a type (`name[<swiftType>]=someItem`),
    /// which returns the provided type as-is.
    func bindings(for namedItem: InternalGrammar.NamedItem) -> [Binding] {
        switch namedItem {
        case .item(let name?, let item, let type):
            return [(name, type ?? typeForItem(item).scg_unwrapped())]

        case .item(_, let item, _):
            let bindings = bindings(for: item)
            return bindings.scg_unwrapped()

        case .lookahead:
            return []
        }
    }

    /// Returns bindings for a given item, to be used for if-let binding.
    ///
    /// The result might have more than one element, in case the item expands
    /// into auxiliary rules with multiple elements.
    ///
    /// - note: Bindings from this layer have extra optionality still.
    func bindings(for item: InternalGrammar.Item) -> [Binding] {
        switch item {
        case .zeroOrMore(let atom, _),
            .oneOrMore(let atom, _),
            .gather(_, let atom):
            // Remove one layer of optionality, as it's consumed by the repetition
            // process to gauge when the repetition should end
            var bindings = bindings(for: atom)
            bindings = bindings.scg_unwrapped()
            // Propagate binding names if this is a single-binding construct
            if bindings.count == 1 {
                return [(bindings[0].label, .array(bindings[0].type))]
            }

            return [(nil, .array(bindings.scg_asTupleType()))]

        case .optional(let atom):
            // TODO: Validate an optional bind of multiple results
            return bindings(for: atom).scg_optionalWrapped()

        case .optionalItems(let alts):
            return computeBindings(alts)

        case .atom(let atom):
            return bindings(for: atom)
        }
    }

    /// Returns bindings for a given atom, to be used for if-let binding.
    ///
    /// The result might have more than one element, in case the atom expands
    /// into auxiliary rules with multiple elements.
    ///
    /// - note: Bindings from this layer have extra optionality still.
    func bindings(for atom: InternalGrammar.Atom) -> [Binding] {
        switch atom {
        case .group(let alts):
            return computeBindings(alts)

        case .token(let ident):
            return [(implicitBindings ? ident.lowercased() : nil, typeForAtom(atom))]

        case .anyToken(let ident):
            return [(implicitBindings ? ident.lowercased() : nil, typeForAtom(atom))]

        case .ruleName(let ident):
            return [(implicitBindings ? ident : nil, typeForAtom(atom))]

        case .string(_, let literal):
            let identifier = tokenName(ofRawLiteral: literal)
            return [(implicitBindings ? identifier : nil, typeForAtom(atom))]
        }
    }

    /// Escapes the given identifier to something that can be declared as a local
    /// or member name in Swift.
    func escapeIdentifier(_ ident: String) -> String {
        // Wildcard; return unchanged
        if ident == "_" {
            return ident
        }

        // Identifier already escaped; return unchanged
        if ident.hasPrefix("`") && ident.hasSuffix("`") {
            return ident
        }

        if SwiftCodeGen.invalidBareIdentifiers.contains(ident) {
            return "`\(ident)`"
        }

        return ident
    }

    // MARK: Rule/alt bindings

    /// Computes the implicit bindings for a given rule.
    ///
    /// If no suitable set of common elements could be extracted, an empty array
    /// is returned.
    ///
    /// - note: Result removes a layer of optional wrapping from all bindings,
    /// since the code generator assumes that the bindings are part of a
    /// successful if-let pattern.
    func computeImplicitBindings(
        _ rule: InternalGrammar.Rule
    ) -> [Binding] {

        computeBindings(rule.alts)
    }

    /// Computes the bindings for a given set of alts.
    ///
    /// If no suitable set of common elements could be extracted, an empty array
    /// is returned.
    ///
    /// - note: Result removes a layer of optional wrapping from all bindings,
    /// since the code generator assumes that the bindings are part of a
    /// successful if-let pattern.
    func computeBindings(
        _ alts: [InternalGrammar.Alt]
    ) -> [Binding] {

        // Fill bindings

        var firstBindingNames: [String] = [] // For ordering later
        var bindingsPerAlt: [[String: CommonAbstract.SwiftType]] = []
        for alt in alts {
            var bindings: [String: CommonAbstract.SwiftType] = [:]

            for case let (name?, type?) in computeBindings(alt) {
                firstBindingNames.append(name)
                bindings[name] = type
            }

            bindingsPerAlt.append(bindings)
        }

        // Only consider alts that occur in all alts, with the same type
        var commonBindings: [String: CommonAbstract.SwiftType] = [:]
        let allKeys = Set(bindingsPerAlt.flatMap(\.keys))

        for key in allKeys {
            guard bindingsPerAlt.allSatisfy({ $0[key] != nil }) else {
                continue
            }
            let bindingTypes = Set(bindingsPerAlt.compactMap({ $0[key] }))
            guard bindingTypes.count == 1, let type = bindingTypes.first else {
                continue
            }

            commonBindings[key] = type
        }

        var pairs = commonBindings.map {
            ($0.key, $0.value)
        }
        // Order bindings based on their appearance on the first alt
        pairs.sort { (b1, b2) in
            guard
                let index1 = firstBindingNames.firstIndex(of: b1.0),
                let index2 = firstBindingNames.firstIndex(of: b2.0)
            else {
                // Found bindings that are not in common with all/first alt?
                return false
            }

            return index1 < index2
        }

        return pairs.map {
            (label: $0.0, type: $0.1)
        }
    }

    /// Computes the bindings for a given of alt based on the elements that are
    /// contained within.
    ///
    /// - note: Result removes a layer of optional wrapping from all bindings,
    /// since the code generator assumes that the bindings are part of a
    /// successful if-let pattern.
    func computeBindings(
        _ alt: InternalGrammar.Alt
    ) -> [Binding] {

        return computeBindings(alt.namedItems)
    }

    /// Computes the bindings for a given sequence of named items based on the
    /// elements that are contained within.
    ///
    /// - note: Result removes a layer of optional wrapping from all bindings,
    /// since the code generator assumes that the bindings are part of a
    /// successful if-let pattern.
    func computeBindings(
        _ namedItems: some Sequence<InternalGrammar.NamedItem>
    ) -> [Binding] {

        var result: [Binding] = []
        for item in namedItems {
            for binding in bindings(for: item) {
                result.append(binding)
            }
        }
        return result
    }
}
