@grammar """
start: a ;
a: (b d)*< c ;
b: b 'c' ;
c[[TokenType]]: d='d'+ ;
d[TokenType]: d='d' ;
e: (b d)*> c ;
""" ;

@expectedParser """
extension Parser {
    /// ```
    /// start:
    ///     | a
    ///     ;
    /// ```
    @memoized("start")
    @inlinable
    public func __start() throws -> Node? {
        let mark = self.mark()

        if
            let a = try self.a()
        {
            return a
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// a:
    ///     | (b d)*< c
    ///     ;
    /// ```
    @memoized("a")
    @inlinable
    public func __a() throws -> Node? {
        let mark = self.mark()

        if
            case let (_?, c?) = try self._a_nsr()
        {
            return Node()
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// b:
    ///     | b 'c'
    ///     ;
    /// ```
    @memoizedLeftRecursive("b")
    @inlinable
    public func __b() throws -> Node? {
        let mark = self.mark()

        if
            let b = try self.b(),
            let _ = try self.expect("c")
        {
            return Node()
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// c[[TokenType]]:
    ///     | d='d'+
    ///     ;
    /// ```
    @memoized("c")
    @inlinable
    public func __c() throws -> [TokenType]? {
        let mark = self.mark()

        if
            let d = try self.repeatOneOrMore({
                try self.expect("d")
            })
        {
            return d
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// d[TokenType]:
    ///     | d='d'
    ///     ;
    /// ```
    @memoized("d")
    @inlinable
    public func __d() throws -> TokenType? {
        let mark = self.mark()

        if
            let d = try self.expect("d")
        {
            return d
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// e:
    ///     | (b d)*> c
    ///     ;
    /// ```
    @memoized("e")
    @inlinable
    public func __e() throws -> Node? {
        let mark = self.mark()

        if
            case let (_?, c?) = try self._e_nsr()
        {
            return Node()
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// _a_nsr[([(b: Node, d: TokenType)], c: [TokenType])]:
    ///     | (b d)*< _a_nsr_tail
    ///     ;
    /// ```
    @memoized("_a_nsr")
    @inlinable
    public func ___a_nsr() throws -> ([(b: Node, d: TokenType)]?, c: [TokenType]?) {
        var _current: [(b: Node, d: TokenType)] = []

        while true {
            let mark = self.mark()

            if
                let c = try self._a_nsr_tail()
            {
                return (_current, c)
            }

            self.restore(mark)

            // Collect an extra item and try again
            if
                case let (b?, d?) = try self.__a_nsr__group_()
            {
                _current.append((b, d))
            } else {
                break
            }
        }

        return (nil, nil)
    }

    /// ```
    /// _e_nsr[([(b: Node, d: TokenType)], c: [TokenType])]:
    ///     | (b d)*> _a_nsr_tail
    ///     ;
    /// ```
    @memoized("_e_nsr")
    @inlinable
    public func ___e_nsr() throws -> ([(b: Node, d: TokenType)]?, c: [TokenType]?) {
        let _mark = self.mark()

        // Start by fetching as many productions as possible
        guard
            var _current: [(Mark, (b: Node, d: TokenType))] = try self.repeatZeroOrMore({
                if case let (b?, d?) = try self.__a_nsr__group_() { return (self.mark(), (b, d)) }
                return nil
            })
        else {
            return (nil, nil)
        }

        while true {
            let _endMark = _current.last?.0 ?? _mark
            self.restore(_endMark)

            if
                let c = try self._a_nsr_tail()
            {
                return (_current.map(\\.1), c)
            } else if _current.isEmpty {
                return (nil, nil)
            }

            // Drop an item, backtrack the parser, and try again
            _current.removeLast()
        }

        return (nil, nil)
    }

    /// ```
    /// _a_nsr_tail[[TokenType]]:
    ///     | c { c }
    ///     ;
    /// ```
    @memoized("_a_nsr_tail")
    @inlinable
    public func ___a_nsr_tail() throws -> [TokenType]? {
        let mark = self.mark()

        if
            let c = try self.c()
        {
            return c
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// __a_nsr__group_[(b: Node, d: TokenType)]:
    ///     | b d { (b: b, d: d) }
    ///     ;
    /// ```
    @memoized("__a_nsr__group_")
    @inlinable
    public func ____a_nsr__group_() throws -> (b: Node?, d: TokenType?) {
        let mark = self.mark()

        if
            let b = try self.b(),
            let d = try self.d()
        {
            return (b: b, d: d)
        }

        self.restore(mark)
        return (nil, nil)
    }
}
""" ;

start: '' ;
