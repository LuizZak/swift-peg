// HEADS UP! Automatically generated by SwiftCodeGenTests.swift
@testable import SwiftPEG

@usableFromInline
enum TestGrammarAST {
    @usableFromInline
    indirect enum Expr: CustomStringConvertible {
        case add(Self, Term)
        case sub(Self, Term)
        case term(Term)

        @usableFromInline
        var description: String {
            switch self {
            case .add(let l, let r): return "\(l) + \(r)"
            case .sub(let l, let r): return "\(l) - \(r)"
            case .term(let term): return term.description
            }
        }
    }

    @usableFromInline
    indirect enum Term: CustomStringConvertible {
        case mul(Self, Factor)
        case div(Self, Factor)
        case factor(Factor)

        @usableFromInline
        var description: String {
            switch self {
            case .mul(let l, let r): return "\(l) * \(r)"
            case .div(let l, let r): return "\(l) / \(r)"
            case .factor(let factor): return factor.description
            }
        }
    }

    @usableFromInline
    indirect enum Factor: CustomStringConvertible {
        case expr(Expr)
        case atom(Atom)

        @usableFromInline
        var description: String {
            switch self {
            case .expr(let expr): return "(\(expr.description))"
            case .atom(let atom): return atom.description
            }
        }
    }

    @usableFromInline
    enum Atom: CustomStringConvertible {
        case name(Substring)
        case number(Double)

        @usableFromInline
        var description: String {
            switch self {
            case .name(let name): return String(name)
            case .number(let number): return number.description
            }
        }
    }

    @usableFromInline
    enum Token: RawTokenType, ExpressibleByStringLiteral {
        @usableFromInline
        typealias TokenKind = TestGrammarAST.TokenKind
        @usableFromInline
        typealias TokenString = Substring

        case whitespace(Substring)
        case name(Substring)
        case number(Double, Substring)
        case newline
        case add
        case sub
        case mul
        case div
        case lp
        case rp

        @inlinable
        var length: Int {
            string.count
        }

        @inlinable
        var kind: TestGrammarAST.TokenKind {
            switch self {
            case .whitespace: return .whitespace
            case .name: return .name
            case .number: return .number
            case .newline: return .newline
            case .add: return .add
            case .sub: return .sub
            case .mul: return .mul
            case .div: return .div
            case .lp: return .lp
            case .rp: return .rp
            }
        }

        @inlinable
        var string: Substring {
            switch self {
            case .whitespace(let value): return value
            case .name(let value): return value
            case .number(_, let value): return value
            case .newline: return "\n"
            default:
                return Substring(kind.description)
            }
        }

        @inlinable
        init(stringLiteral value: String) {
            if let value = Self.from(value[...]) {
                self = value
            } else {
                fatalError("Invalid token literal \(value)")
            }
        }

        @inlinable
        static func from(_ string: Substring) -> Self? {
            guard let first = string.first else {
                return nil
            }

            switch first {
            case "+": return .add
            case "-": return .sub
            case "*": return .mul
            case "/": return .div
            case "(": return .lp
            case ")": return .rp
            case "\n": return .newline
            case let c where c.isWhitespace:
                if let match = Self._parseWhitespace(string) {
                    return .whitespace(match)
                }
                return nil
            case let c where c.isWholeNumber:
                if let number = Self._parseNumber(string), let double = Double(number) {
                    return .number(double, number)
                }
                return nil
            default:
                // Try name
                if let ident = Self._parseName(string) {
                    return .name(ident)
                }
                return nil
            }
        }

        @inlinable
        static func _parseWhitespace<S: StringProtocol>(_ string: S) -> Substring? where S.SubSequence == Substring {
            var stream = StringStream(source: string)
            guard !stream.isEof else { return nil }

            switch stream.next() {
            case let c where c.isWhitespace:
                break
            default:
                return nil
            }

            loop:
            while !stream.isEof {
                switch stream.peek() {
                case let c where c.isWhitespace:
                    stream.advance()
                default:
                    break loop
                }
            }

            return stream.substring
        }

        @inlinable
        static func _parseName<S: StringProtocol>(_ string: S) -> Substring? where S.SubSequence == Substring {
            var stream = StringStream(source: string)
            guard !stream.isEof else { return nil }

            switch stream.next() {
            case let c where c.isLetter:
                break
            case "_":
                break
            default:
                return nil
            }

            loop:
            while !stream.isEof {
                switch stream.peek() {
                case let c where c.isLetter:
                    stream.advance()
                case let c where c.isWholeNumber:
                    stream.advance()
                case "_":
                    stream.advance()
                default:
                    break loop
                }
            }

            return stream.substring
        }

        @inlinable
        static func _parseNumber<S: StringProtocol>(_ string: S) -> Substring? where S.SubSequence == Substring {
            var stream = StringStream(source: string)
            guard !stream.isEof else { return nil }

            switch stream.next() {
            case let c where c.isWholeNumber:
                break
            default:
                return nil
            }

            loop:
            while !stream.isEof {
                switch stream.peek() {
                case let c where c.isWholeNumber:
                    stream.advance()
                default:
                    break loop
                }
            }

            if !stream.isEof && stream.advanceIfNext(".") {
                loop:
                while !stream.isEof {
                    switch stream.peek() {
                    case let c where c.isWholeNumber:
                        stream.advance()
                    default:
                        break loop
                    }
                }
            }

            return stream.substring
        }

        @inlinable
        static func produceDummy(_ kind: TestGrammarAST.TokenKind) -> TestGrammarAST.Token {
            switch kind {
            case .whitespace: return .whitespace(" ")
            case .name: return .name("<dummy>")
            case .number: return .number(0.0, "0.0")
            case .newline: return .newline
            case .add: return .add
            case .sub: return .sub
            case .mul: return .mul
            case .div: return .div
            case .lp: return .lp
            case .rp: return .rp
            }
        }
    }

    @usableFromInline
    enum TokenKind: String, TokenKindType {
        case whitespace = "<whitespace>"
        case name = "<name>"
        case number = "<number>"
        case newline = "<newline>"
        case add = "+"
        case sub = "-"
        case mul = "*"
        case div = "/"
        case lp = "("
        case rp = ")"

        @inlinable
        var description: String { self.rawValue }
    }
}

@usableFromInline
final class TestGrammarRawTokenizer: RawTokenizerType {
    @usableFromInline
    typealias RawToken = TestGrammarAST.Token
    @usableFromInline
    typealias Location = FileSourceLocation

    @usableFromInline
    internal var _source: String
    @usableFromInline
    internal var _index: String.Index

    /// Internal source location tracker
    @usableFromInline
    internal var _location: FileSourceLocation

    @inlinable
    var isEOF: Bool {
        _index >= _source.endIndex
    }

    @inlinable
    init(source: String) {
        self._source = source
        _index = source.startIndex
        _location = FileSourceLocation(line: 1, column: 1)
    }

    @inlinable
    func next() throws -> (rawToken: RawToken, location: Location)? {
        skipToContent()

        guard _index < _source.endIndex else {
            return nil
        }

        guard
            let token = RawToken.from(_source[_index...]),
            token.length > 0
        else {
            throw Error.unknownToken(index: _index)
        }

        defer { advance(by: token.length) }

        return (token, _location)
    }

    @inlinable
    internal func skipToContent() {
        var lastIndex = _index
        repeat {
            lastIndex = _index
            skipComments()
        } while _index < _source.endIndex && lastIndex != _index
    }

    @inlinable
    internal func skipLine() {
        while _index < _source.endIndex && _source[_index] != "\n" {
            advance(by: 1)
        }
        if _index < _source.endIndex {
            advance(by: 1) // Skip linefeed character
        }
    }

    @inlinable
    internal func skipComments() {
        while _index < _source.endIndex && _source[_index] == "#" {
            skipLine()
        }
    }

    @inlinable
    internal func advance(by count: Int) {
        for _ in 0..<count {
            if _source[_index] == "\n" {
                _location.column = 0
                _location.line += 1
            }

            _index = _source.utf8.index(after: _index)
            _location.column += 1
        }
    }

    @usableFromInline
    enum Error: TokenizerError {
        case unknownToken(index: String.Index)

        @usableFromInline
        var description: String {
            switch self {
            case .unknownToken(let index):
                return "Unknown token @ \(index)"
            }
        }
    }
}

final class TestGrammarParser<Raw: RawTokenizerType>: PEGParser<Raw> where Raw.RawToken == TestGrammarAST.Token {
    @inlinable
    func NAME() throws -> Substring? {
        if let token = try self.expect(kind: .name) {
            return token.rawToken.string
        }
        return nil
    }

    @inlinable
    func NUMBER() throws -> Double? {
        if
            let token = try self.expect(kind: .number),
            case .number(let value, _) = token.rawToken
        {
            return value
        }
        return nil
    }

    @inlinable
    func NEWLINE() throws -> Substring? {
        if let token = try self.expect(kind: .newline) {
            return token.rawToken.string
        }
        return nil
    }
}

extension TestGrammarParser {
    /// ```
    /// start[TestGrammarAST.Expr]:
    ///     | expr _=NEWLINE? { expr }
    ///     ;
    /// ```
    @memoized("start")
    @inlinable
    public func __start() throws -> TestGrammarAST.Expr? {
        let mark = self.mark()

        if
            let expr = try self.expr(),
            let _ = try self.optional({
                try self.NEWLINE()
            })
        {
            return expr
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// expr[TestGrammarAST.Expr]:
    ///     | expr '+' term { .add(expr, term) }
    ///     | expr '-' term { .sub(expr, term) }
    ///     | term { .term(term) }
    ///     ;
    /// ```
    @memoizedLeftRecursive("expr")
    @inlinable
    public func __expr() throws -> TestGrammarAST.Expr? {
        let mark = self.mark()

        if
            let expr = try self.expr(),
            let _ = try self.expect("+"),
            let term = try self.term()
        {
            return .add(expr, term)
        }

        self.restore(mark)

        if
            let expr = try self.expr(),
            let _ = try self.expect("-"),
            let term = try self.term()
        {
            return .sub(expr, term)
        }

        self.restore(mark)

        if
            let term = try self.term()
        {
            return .term(term)
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// term[TestGrammarAST.Term]:
    ///     | term '*' factor { .mul(term, factor) }
    ///     | term '/' factor { .div(term, factor) }
    ///     | factor { .factor(factor) }
    ///     ;
    /// ```
    @memoizedLeftRecursive("term")
    @inlinable
    public func __term() throws -> TestGrammarAST.Term? {
        let mark = self.mark()

        if
            let term = try self.term(),
            let _ = try self.expect("*"),
            let factor = try self.factor()
        {
            return .mul(term, factor)
        }

        self.restore(mark)

        if
            let term = try self.term(),
            let _ = try self.expect("/"),
            let factor = try self.factor()
        {
            return .div(term, factor)
        }

        self.restore(mark)

        if
            let factor = try self.factor()
        {
            return .factor(factor)
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// factor[TestGrammarAST.Factor]:
    ///     | '(' expr ')' { .expr(expr) }
    ///     | atom { .atom(atom) }
    ///     ;
    /// ```
    @memoized("factor")
    @inlinable
    public func __factor() throws -> TestGrammarAST.Factor? {
        let mark = self.mark()

        if
            let _ = try self.expect("("),
            let expr = try self.expr(),
            let _ = try self.expect(")")
        {
            return .expr(expr)
        }

        self.restore(mark)

        if
            let atom = try self.atom()
        {
            return .atom(atom)
        }

        self.restore(mark)
        return nil
    }

    /// ```
    /// atom[TestGrammarAST.Atom]:
    ///     | NAME { .name(name) }
    ///     | NUMBER { .number(number) }
    ///     ;
    /// ```
    @memoized("atom")
    @inlinable
    public func __atom() throws -> TestGrammarAST.Atom? {
        let mark = self.mark()

        if
            let name = try self.NAME()
        {
            return .name(name)
        }

        self.restore(mark)

        if
            let number = try self.NUMBER()
        {
            return .number(number)
        }

        self.restore(mark)
        return nil
    }
}
